# my_sylar
this is a learning program

### 参考资料

sylar源码git地址：`https://github.com/sylar-yin/sylar`

sylar配套视频地址：`https://www.bilibili.com/video/BV184411s7qF?p=6&spm_id_from=pageDriver&vd_source=e5ea4d6dfdbf10d1586394cd882ac61e`

路人大佬注写的sylar源码git地址：`https://github.com/zhongluqiang/sylar-from-scratch`

### 项目进度

| 日期       | 事件                                                         |
| ---------- | ------------------------------------------------------------ |
| 2022-06-20 | 再战sylar项目，最开始因为字体和声音都很小劝退了。从日志模块开始(视频学习日志模块) |
| 2022-06-21 | 看完了日志模块大部分代码，视频差2个半                        |
| 2022-06-22 | 日志模块源代码和视频看完，开始自己着手开发                   |
| 2022-06-23 | 完成log.h文件，log.cpp开头。对比sylar源码，可能有些地方会有偏差，但是会以实现相同的功能为目标。结构如下：<br /> 顶层 ： LogManager日志器管理者    以map的形式管理数个Logger，可以删除、添加、获取某个日志器，默认生成主日志器<br/>              Logger日志器             以vector管理数个appender，可以添加删除appender，有写日志的方法<br/>              Appender输出器           输出器控制输出的地方，控制某个日志级别是否可以输出，控制输出的格式(控制LogFormatter)<br/>              LogFormatter格式器       以某种格式输出日志 可以修改格式<br/> 底层：  LogEvent日志事件          事件中有日志的所有信息，但是经过LogFormatter之后信息并不会全部输出，会按照指定的格式进行输出 |
| 2022-6-24  | log.cpp从底层写起，写完了LogLevel、LogEvent、LogFormat。<br /> 其中LogFormat的init方法算是日志模块中的重难点，这里用了一种另一套算法去解析格式。 <br /> 注意使用std::ostream时的引用 |
| 2022-06-25 | 写完了LogAppender以及其拓展类的实现，以及一部分Logger的实现  |
| 2022-06-26 | 基本完成日志模块，剩下一些细节需要打磨。                     |
| 2022-06-27 | 完善日志模块宏定义，可以利用宏写流式日志或格式化日志<br />日志模块代码在分支：util01 |
| 2022-06-30 | 观看配置系统视频p9-p11                                       |
| 2022-07-20 | 到目前进度：<br />视频观看至p15。<br />代码完成至可以利用代码约定配置，实现从stl常见容器与自定义类读取到配置，实现了结合yaml从文件读取简单类型与上述类型。<br /><br />**总结**：<br />采用约定大于配置的思想，利用yaml-cpp实现yaml文件的数据读取，利用yaml-cpp可以将yaml文件中的map与c++的map(或者其他stl中的容器)进行转化。<br />**重难点**：<br />掌握yaml-cpp库用法<br />boost::lexical_cast是实现配置系统的主力函数     这个boost中的函数功能主要将  不同类型转换为对应的string类型，或者将string转化为T类型<br />偏特化LexicalCast，使其支持不同的stl容器从容器转换为string  或 从string转换成为对应的stl容器    转换过程利用的yaml作为中转<br />dynamic_pointer_cast   这个函数可以将基类转换为派生类   只适用于智能指针    <br />**设计**：<br />基类是正常的类，而派生类是函数模板类，灵活利用了派生类的偏特化，将string与不同的形式数据结构进行相互转换。<br />这种设计模式的优点，如果新增一个类型的转化，只需要支持这种类型的偏特化即可。 |
| 2022-07-27 | 视频16p-20p跳过观看，通过看源码实现相同的功能，实现了日志系统和配置系统的结合。<br />设置回调函数，当yaml中的日志发生改变的时候，系统自动的修改对应的日志配置。<br />当从yml读取信息进行分析时，如果发现值改变，则执行绑定的回调函数。<br />回调函数的基本单位是配置项，不同的配置项可以绑定不同的回调函数。<br />回顾整个配置系统，约定大于配置是中心思想。如果没有约定，那么yml中配置再多也不会生效。<br />到此配置系统完毕。<br />日志模块代码在分支：util02 |
| 2022-08-23 | 观看完21p-25p。<br />实现线程模块，线程模块主要是封装了线程、封装了多种类型的锁<br />初始化线程时传入线程中要运行的函数，在run函数中运行<br />线程中定义了thread_local类型的变量，存储每个线程本身，和线程名称<br />定义了信号量、互斥量、自旋锁、原子锁、读写锁。<br />其中锁(互斥量)的调用，在其实现类的对象的构造函数中加锁，释放对象的时候解锁<br />其中加锁和解锁的方式是一种设计模式，值得学习。<br />锁的实现细节也需要进行深入了解，掌握锁的原理。<br />将线程和锁与日志和配置系统进行了整合，为需要加锁的地方添加了锁。<br />在日志模块进行加锁性能测试，得出不同的场景应选择对应的锁。<br />修复了日志模块的一个bug(日志级别没有正确赋值问题)<br />线程和锁模块代码在分支：util03 |
| 2022-09-16 | 观看完26p-29p。<br />实现了协程模块。协程是轻量级的线程。利用ucontext实现协程。<br />协程模块：<br />依赖线程运行，每个线程创建一个主协程，由主协程统一调度该线程下的所有子协程。不允许子协程之间进行相互调度。<br />既当子协程调度结束之后，应将程序控制权交付给主协程。<br />利用thread_local实现隔离每个线程的主协程。<br />难点：<br />想明白    线程---->主协程<------->子协程    之间的关系和切换顺序。<br />时刻明白程序执行到某个点时，是哪个协程在运行。<br />实现单个线程之间的主协程和子协程可以相互调用，但是又不影响其他线程的协程。<br />协程模块代码分支：util04 |
| 2022-09-21 | 修改协程模块bug：显示协程号问题，GetFiberId函数没有写返回值，log中没有正常打印协程id。<br />观看完30p-35p。<br />实现的协程调度模块。该模块是整个系统的核心部分。<br />利用线程池+协程实现任务调度，协程是执行任务的最小单元(不同于线程系统)。<br />实现：<br />1、线程池   2、协程队列   <br />线程池中的线程通过锁的约束竞争消费协程队列里面的任务(任务可以是函数也可以是封装好的协程)。<br />每个线程池中的线程绑定相同的协程调度模式。<br />线程竞争到协程任务之后，用一个新的协程(可以重复利用)去执行任务，当任务执行结束必须可以重新返回到线程中。<br />可以指定协程任务具体在那个线程中执行。<br />难点：<br />在之前的协程模块，所有的子协程都与线程的主协程进行切换，但是在本模块，子协程都与调度协程进行切换。因为有将主线程加入线程池的功能，逻辑会比较复杂一些。这里只要哪个协程绑定了Scheduler的run方法，哪个协程就是调度协程，协程调度模块的所有协程都应该与该协程进行交互切换。为了不使用协程调度模块也能实现协程模块原有的功能，在修改了协程模块的一部分函数。<br />协程调度模块代码分支：util05 |
| 2022-10-10 | 实现IO协程调度模块：利用epoll_wait() 实现 阻塞空线程(没有任务执行的线程)，当有事件到来时，唤醒epoll，跳出idle函数。利用管道，也可以实现无事件到来时(其实是有管道事件到来)，随时唤醒epoll跳出idle函数。<br />观看完36p-39p。<br />实现基于epoll的IO协程调度模块。可以处理各种IO事件。<br />可以在某个fd上添加删除事件，为事件绑定回调，在事件发生时候执行对应的回调。<br />难点：<br />重写canStop、idle、tickle函数。<br />canStop函数需要添加额外的停止条件判断<br />idle函数需要继承epoll实现空闲阻塞，有事件或想唤醒时可以跳出epoll，回到run函数中<br />tickle函数需要唤醒epoll<br />为fd上绑定删除添加事件，并且为不同的事件添加不同的回调函数<br />回调函数会进入schedule中的协程任务队列中，等待线程执行<br />IO协程调度模块代码分支：util06 |
| 2022-10-13 | 实现定时器模块：定时器模块需要依赖一个能够计时的模块一起运转。<br />观看完视频40p-42p。<br />实现定时器模块，将定时器模块与IO协程调度模块相结合，完成定时器功能。<br />定时器模块由两个类组成，一个是定时器本身，一个是定时器的管理类。<br />所有的定时器都应该在定时器管理类中生成。<br />实现添加、删除、修改定时器等操作，定时器分为普通定时器、循环定时器、带有判断条件的定时器。<br />实现在某时刻，删除过期的定时器，获取到过期定时器的执行函数。<br />当添加的定时器是定时器队列中的第一个要执行的函数时，可以触发某个事件(这个事件是一个虚函数，可以被实现成任意样子)。<br />在IO协程调度模块中，IO调度器继承了定时器管理类，可以操作定时器，利用epoll_wait的阻塞时间机制，将要执行定时器的时间设置为epoll_wait的阻塞时间，当epoll_wait阻塞时间到期，则会执行所有过期的定时器所绑定的任务。<br />定时器模块，需要一个能不断获取时间的模块一起驱动，定时器本身不会去主动执行任务。<br />定时器模块代码分支：util07 |
| 2022-11-07 | 实现hook模块：自实现某些系统函数，将一些io函数封装成非阻塞函数<br />观看完视频43p-48p,并实现对应代码<br />阻塞变非阻塞思路：<br />首先判断fd是否是非阻塞的，如果不是非阻塞，则直接使用原函数。<br />如果是非阻塞的，执行函数，拿到函数的返回值，利用返回值进行筛选。因为是非阻塞的，等于先让程序往后走，io操作等待io信号，如果长时间没有io信号到来，应该可以删除或者修改io操作，既执行超时处理。这点可以利用条件定时器实现，当程序往下执行时，首先将fd添加到条件定时器，在给io绑定事件。如果绑定成功将程序换出，等待io信号唤醒或者定时器唤醒。如果被io信号信号唤醒，说明io成功。如果被定时器唤醒，则说明io超时失败。唤醒通过epoll_wait实现。<br />hook模块代码分支：util08 |
| 2022-12-15 | 封装自己的Address类。<br />观看完视频49p-53p，并实现对应的代码。<br />利用Address可以实现统一的地址封装，可以得到有关ip、网卡、域名的信息。<br />兼容IPv4和IPv6，也兼容Unix的地址类型。<br />可以利用二进制或者是点分十进制生成对应的Address。<br />此处代码的封装可以在其他地方直接利用。<br />Address地址封装：util09 |







互斥量锁写日志：

![image-20220810145723148](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220810145723148.png)

自旋锁写日志：

![image-20220810145924897](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220810145924897.png)





###### 协程模块

每个线程有一个主协程，主协程调度该线程下的所有子协程

​								<------------> 子协程    

 线程  -----> 主协程  <------------> 子协程    

​								<------------> 子协程    

协程调度：

​					1 ---- N                      1------N

scheduler  ------------->    thread   -------------> fiber

 

scheduler:

1、线程池

2、协程调度器，将协程指定到相应的线程上执行





分支切换

git branch
 git checkout -b util03
git push origin util03
git branch --set-upstream-to=origin/util03
git pull
git checkout main
git status